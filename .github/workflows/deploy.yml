# ============================================================================
# CHM-SISTEMA - Workflow CI/CD Completo
# ============================================================================
# @author ch-mestriner (https://ch-mestriner.com.br)
# @date 27/12/2025 14:40
# @version 2.3.5
#
# FLUXO AUTOMÁTICO:
# GitHub Push → Validate Secrets → Restore DB → Clear Cache → Deploy → Checklist
#
# REGRAS:
# - 100% automático, sem intervenção manual
# - Falha se qualquer secret estiver faltando
# - Restore do banco ANTES do deploy
# - Validação pós-deploy obrigatória
# ============================================================================

name: Deploy Produção

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:
    inputs:
      skip_restore:
        description: 'Pular restore do banco (apenas código)'
        required: false
        default: false
        type: boolean

env:
  PRODUCTION_URL: https://chm-sistema.com.br
  PHP_VERSION: '8.1'
  BACKUP_FILE: backups/db/backup-db-27-12-2025_02-00-01.sql.gz

jobs:
  # ==========================================================================
  # JOB 1: VALIDAR SECRETS (OBRIGATÓRIO)
  # ==========================================================================
  validate-secrets:
    name: 1. Validar Secrets
    runs-on: ubuntu-latest
    steps:
      - name: Verificar secrets obrigatórios
        env:
          FTP_HOST: ${{ secrets.FTP_HOST }}
          FTP_USER: ${{ secrets.FTP_USER }}
          FTP_PASS: ${{ secrets.FTP_PASS }}
          DB_HOST: ${{ secrets.DB_HOST }}
          DB_PORT: ${{ secrets.DB_PORT }}
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASS: ${{ secrets.DB_PASS }}
          DEPLOY_SECRET: ${{ secrets.DEPLOY_SECRET }}
        run: |
          echo "=== VALIDANDO SECRETS OBRIGATÓRIOS ==="
          MISSING=""
          
          [ -z "$FTP_HOST" ] && MISSING="$MISSING FTP_HOST"
          [ -z "$FTP_USER" ] && MISSING="$MISSING FTP_USER"
          [ -z "$FTP_PASS" ] && MISSING="$MISSING FTP_PASS"
          [ -z "$DB_HOST" ] && MISSING="$MISSING DB_HOST"
          [ -z "$DB_NAME" ] && MISSING="$MISSING DB_NAME"
          [ -z "$DB_USER" ] && MISSING="$MISSING DB_USER"
          [ -z "$DB_PASS" ] && MISSING="$MISSING DB_PASS"
          [ -z "$DEPLOY_SECRET" ] && MISSING="$MISSING DEPLOY_SECRET"
          
          if [ -n "$MISSING" ]; then
            echo "=============================================="
            echo "  ✗ ERRO: SECRETS FALTANDO!"
            echo "=============================================="
            echo "  Configure os seguintes secrets no GitHub:"
            echo "  Settings → Secrets and variables → Actions"
            echo ""
            for SECRET in $MISSING; do
              echo "  • $SECRET"
            done
            echo "=============================================="
            exit 1
          fi
          
          echo "✓ FTP_HOST configurado"
          echo "✓ FTP_USER configurado"
          echo "✓ FTP_PASS configurado"
          echo "✓ DB_HOST configurado"
          echo "✓ DB_NAME configurado"
          echo "✓ DB_USER configurado"
          echo "✓ DB_PASS configurado"
          echo "✓ DEPLOY_SECRET configurado"
          echo ""
          echo "=== TODOS OS SECRETS VALIDADOS ==="

  # ==========================================================================
  # JOB 2: VALIDAR CÓDIGO
  # ==========================================================================
  validate-code:
    name: 2. Validar Código
    needs: validate-secrets
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: ${{ env.PHP_VERSION }}
          extensions: mbstring, pdo, pdo_mysql, json, curl

      - name: Validar sintaxe PHP
        run: |
          echo "=== Validando sintaxe PHP ==="
          ERROR_COUNT=0
          while IFS= read -r -d '' file; do
            if ! php -l "$file" > /dev/null 2>&1; then
              echo "✗ Erro em: $file"
              php -l "$file"
              ERROR_COUNT=$((ERROR_COUNT + 1))
            fi
          done < <(find . -name "*.php" -not -path "./vendor/*" -print0)
          
          if [ $ERROR_COUNT -gt 0 ]; then
            echo "✗ $ERROR_COUNT arquivos com erro de sintaxe"
            exit 1
          fi
          echo "✓ Sintaxe PHP OK"

      - name: Verificar arquivos críticos
        run: |
          echo "=== Verificando arquivos críticos ==="
          CRITICAL_FILES=(
            "index.php"
            "app/index.php"
            "app/config/config.php"
            "app/config/env_loader.php"
            ".htaccess"
            "app/.htaccess"
          )
          
          for FILE in "${CRITICAL_FILES[@]}"; do
            if [ -f "$FILE" ]; then
              echo "✓ $FILE existe"
            else
              echo "✗ $FILE FALTANDO!"
              exit 1
            fi
          done
          
          echo "✓ Todos arquivos críticos presentes"

      - name: Verificar backup existe
        run: |
          echo "=== Verificando backup ==="
          if [ -f "${{ env.BACKUP_FILE }}" ]; then
            SIZE=$(du -h "${{ env.BACKUP_FILE }}" | cut -f1)
            echo "✓ Backup encontrado: ${{ env.BACKUP_FILE }} ($SIZE)"
          else
            echo "⚠ Backup não encontrado no repositório"
            echo "  Esperado: ${{ env.BACKUP_FILE }}"
            echo "  O restore será feito via servidor se disponível"
          fi

  # ==========================================================================
  # JOB 3: RESTORE DO BANCO (ANTES DO DEPLOY)
  # ==========================================================================
  restore-database:
    name: 3. Restore Banco de Dados
    needs: validate-code
    if: github.event.inputs.skip_restore != 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Instalar MySQL Client
        run: |
          sudo apt-get update
          sudo apt-get install -y mysql-client gzip

      - name: Restaurar backup do banco
        env:
          DB_HOST: ${{ secrets.DB_HOST }}
          DB_PORT: ${{ secrets.DB_PORT }}
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASS: ${{ secrets.DB_PASS }}
        run: |
          echo "=== RESTAURANDO BANCO DE DADOS ==="
          echo "Backup: ${{ env.BACKUP_FILE }}"
          echo "Host: $DB_HOST"
          echo "Database: $DB_NAME"
          echo ""
          
          # Define porta padrão se não especificada
          DB_PORT="${DB_PORT:-3306}"
          
          # Verifica se o backup existe no repositório
          if [ -f "${{ env.BACKUP_FILE }}" ]; then
            echo "Descompactando backup..."
            gunzip -c "${{ env.BACKUP_FILE }}" > /tmp/restore.sql
            
            echo "Executando restore..."
            mysql -h "$DB_HOST" -P "$DB_PORT" -u "$DB_USER" -p"$DB_PASS" "$DB_NAME" < /tmp/restore.sql
            
            if [ $? -eq 0 ]; then
              echo "✓ Restore concluído com sucesso"
              rm /tmp/restore.sql
            else
              echo "✗ Erro no restore do banco"
              exit 1
            fi
          else
            echo "⚠ Backup não encontrado no repositório"
            echo "Tentando restore via API do servidor..."
            
            RESPONSE=$(curl -sf "${{ env.PRODUCTION_URL }}/api/deploy/restore-db?secret=${{ secrets.DEPLOY_SECRET }}&date=2025-12-27" 2>&1) || {
              echo "⚠ Restore via API falhou: $RESPONSE"
              echo "Continuando sem restore (banco existente será mantido)"
            }
          fi

      - name: Verificar conexão pós-restore
        env:
          DB_HOST: ${{ secrets.DB_HOST }}
          DB_PORT: ${{ secrets.DB_PORT }}
          DB_NAME: ${{ secrets.DB_NAME }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_PASS: ${{ secrets.DB_PASS }}
        run: |
          echo "=== Verificando conexão com banco ==="
          DB_PORT="${DB_PORT:-3306}"
          
          RESULT=$(mysql -h "$DB_HOST" -P "$DB_PORT" -u "$DB_USER" -p"$DB_PASS" "$DB_NAME" -e "SELECT 1 as test;" 2>&1)
          
          if echo "$RESULT" | grep -q "1"; then
            echo "✓ Conexão com banco OK"
          else
            echo "✗ Falha na conexão com banco"
            echo "$RESULT"
            exit 1
          fi

  # ==========================================================================
  # JOB 4: DEPLOY VIA FTP
  # ==========================================================================
  deploy:
    name: 4. Deploy FTP
    needs: [validate-code, restore-database]
    if: always() && needs.validate-code.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Instalar lftp
        run: sudo apt-get update && sudo apt-get install -y lftp

      - name: Criar diretórios necessários
        run: |
          mkdir -p logs
          mkdir -p backup
          mkdir -p app/uploads
          mkdir -p app/cache
          touch logs/.gitkeep
          touch backup/.gitkeep
          touch app/uploads/.gitkeep
          touch app/cache/.gitkeep

      - name: Deploy via FTP
        env:
          FTP_HOST: ${{ secrets.FTP_HOST }}
          FTP_USER: ${{ secrets.FTP_USER }}
          FTP_PASS: ${{ secrets.FTP_PASS }}
          FTP_PATH: ${{ secrets.FTP_PATH }}
        run: |
          echo "=== INICIANDO DEPLOY FTP ==="
          echo "Host: $FTP_HOST"
          echo "Path: ${FTP_PATH:-/}"
          echo ""
          
          # Define path padrão se não especificado
          REMOTE_PATH="${FTP_PATH:-/}"
          
          lftp -c "
            set ssl:verify-certificate no
            set ftp:ssl-allow yes
            set ftp:ssl-force no
            set net:timeout 60
            set net:max-retries 5
            set net:reconnect-interval-base 5
            set net:reconnect-interval-multiplier 1
            open -u $FTP_USER,$FTP_PASS $FTP_HOST
            mirror -R --verbose --delete --parallel=3 \
              --exclude .git/ \
              --exclude .github/ \
              --exclude .gitignore \
              --exclude backups/ \
              --exclude *.md \
              --exclude docs/ \
              --exclude scripts/ \
              --exclude node_modules/ \
              . $REMOTE_PATH
            bye
          "
          
          if [ $? -eq 0 ]; then
            echo ""
            echo "✓ Deploy FTP concluído com sucesso"
          else
            echo "✗ Erro no deploy FTP"
            exit 1
          fi

      - name: Aguardar propagação
        run: |
          echo "Aguardando propagação do deploy..."
          sleep 15

  # ==========================================================================
  # JOB 5: LIMPEZA DE CACHE
  # ==========================================================================
  clear-cache:
    name: 5. Limpar Cache
    needs: deploy
    runs-on: ubuntu-latest
    steps:
      - name: Limpar cache via API
        env:
          DEPLOY_SECRET: ${{ secrets.DEPLOY_SECRET }}
        run: |
          echo "=== LIMPANDO CACHE ==="
          
          # Limpar cache da aplicação
          echo "Limpando cache da aplicação..."
          RESPONSE=$(curl -sf "${{ env.PRODUCTION_URL }}/api/deploy/clear-cache?secret=$DEPLOY_SECRET" 2>&1) || true
          
          if echo "$RESPONSE" | grep -q '"success":true'; then
            echo "✓ Cache da aplicação limpo"
            echo "$RESPONSE" | jq . 2>/dev/null || echo "$RESPONSE"
          else
            echo "⚠ Resposta do clear-cache: $RESPONSE"
          fi
          
          # Limpar OPcache via múltiplas requisições
          echo ""
          echo "Forçando refresh de OPcache..."
          for i in 1 2 3; do
            curl -sf -o /dev/null "${{ env.PRODUCTION_URL }}/?nocache=$RANDOM" || true
            sleep 1
          done
          echo "✓ OPcache atualizado"

  # ==========================================================================
  # JOB 6: CHECKLIST PÓS-DEPLOY
  # ==========================================================================
  post-deploy-checklist:
    name: 6. Checklist Pós-Deploy
    needs: clear-cache
    runs-on: ubuntu-latest
    steps:
      - name: Aguardar estabilização
        run: sleep 5

      - name: "[1/6] Bootstrap - index.php"
        run: |
          echo "=== Teste: Bootstrap ==="
          HTTP_CODE=$(curl -sf -o /dev/null -w "%{http_code}" "${{ env.PRODUCTION_URL }}/")
          
          if [ "$HTTP_CODE" -eq 200 ] || [ "$HTTP_CODE" -eq 302 ]; then
            echo "✓ Bootstrap OK (HTTP $HTTP_CODE)"
          else
            echo "✗ Bootstrap FALHOU (HTTP $HTTP_CODE)"
            curl -sI "${{ env.PRODUCTION_URL }}/" | head -20
            exit 1
          fi

      - name: "[2/6] Roteamento - /login"
        run: |
          echo "=== Teste: Roteamento ==="
          HTTP_CODE=$(curl -sf -o /dev/null -w "%{http_code}" "${{ env.PRODUCTION_URL }}/login")
          
          if [ "$HTTP_CODE" -eq 200 ]; then
            echo "✓ Rota /login OK (HTTP $HTTP_CODE)"
          else
            echo "✗ Rota /login FALHOU (HTTP $HTTP_CODE)"
            exit 1
          fi

      - name: "[3/6] Banco de Dados - Health Check"
        run: |
          echo "=== Teste: Banco de Dados ==="
          RESPONSE=$(curl -sf "${{ env.PRODUCTION_URL }}/api/health" 2>/dev/null || echo '{"status":"error"}')
          
          if echo "$RESPONSE" | grep -q '"database":"ok"'; then
            echo "✓ Conexão com banco OK"
            echo "$RESPONSE" | jq . 2>/dev/null || echo "$RESPONSE"
          elif echo "$RESPONSE" | grep -q '"database":"connected"'; then
            echo "✓ Conexão com banco OK"
          else
            echo "⚠ Health check retornou: $RESPONSE"
            echo "Verificando via página de login..."
            HTTP_CODE=$(curl -sf -o /dev/null -w "%{http_code}" "${{ env.PRODUCTION_URL }}/login")
            if [ "$HTTP_CODE" -eq 200 ]; then
              echo "✓ Página login carrega (banco presumido OK)"
            else
              echo "✗ Falha na verificação do banco"
              exit 1
            fi
          fi

      - name: "[4/6] Calendário/Agenda"
        run: |
          echo "=== Teste: Calendário ==="
          # Testa endpoint da agenda (pode retornar 302 se não autenticado)
          HTTP_CODE=$(curl -sf -o /dev/null -w "%{http_code}" "${{ env.PRODUCTION_URL }}/calendar")
          
          if [ "$HTTP_CODE" -eq 200 ] || [ "$HTTP_CODE" -eq 302 ]; then
            echo "✓ Rota /calendar OK (HTTP $HTTP_CODE)"
          else
            echo "⚠ Rota /calendar retornou HTTP $HTTP_CODE"
          fi

      - name: "[5/6] Verificar ausência de HTTP 500"
        run: |
          echo "=== Teste: Ausência de HTTP 500 ==="
          PAGES=("/" "/login" "/manifest.json" "/api/health")
          FAILED=0
          
          for PAGE in "${PAGES[@]}"; do
            HTTP_CODE=$(curl -sf -o /dev/null -w "%{http_code}" "${{ env.PRODUCTION_URL }}$PAGE" 2>/dev/null || echo "000")
            
            if [ "$HTTP_CODE" -eq 500 ]; then
              echo "✗ HTTP 500 em $PAGE"
              FAILED=1
            elif [ "$HTTP_CODE" -eq 000 ]; then
              echo "⚠ Timeout em $PAGE"
            else
              echo "✓ $PAGE → HTTP $HTTP_CODE"
            fi
          done
          
          if [ $FAILED -eq 1 ]; then
            echo ""
            echo "✗ ERRO: HTTP 500 detectado!"
            exit 1
          fi

      - name: "[6/6] Verificar Logs"
        env:
          DEPLOY_SECRET: ${{ secrets.DEPLOY_SECRET }}
        run: |
          echo "=== Teste: Logs ==="
          # Verifica se o endpoint de health reporta logs funcionando
          RESPONSE=$(curl -sf "${{ env.PRODUCTION_URL }}/api/health" 2>/dev/null || echo '{}')
          
          if echo "$RESPONSE" | grep -q '"logs":"ok"'; then
            echo "✓ Sistema de logs OK"
          else
            echo "⚠ Status de logs não verificável via API"
            echo "  (Logs são criados automaticamente pelo PHP)"
          fi

      - name: "RESUMO FINAL"
        run: |
          echo ""
          echo "╔════════════════════════════════════════════════════════════╗"
          echo "║                                                            ║"
          echo "║   ✓ DEPLOY CONCLUÍDO COM SUCESSO                          ║"
          echo "║                                                            ║"
          echo "╠════════════════════════════════════════════════════════════╣"
          echo "║  URL:     ${{ env.PRODUCTION_URL }}"
          echo "║  Data:    $(date '+%Y-%m-%d %H:%M:%S UTC')"
          echo "║  Commit:  ${{ github.sha }}"
          echo "║  Branch:  ${{ github.ref_name }}"
          echo "║  Autor:   ${{ github.actor }}"
          echo "╠════════════════════════════════════════════════════════════╣"
          echo "║  CHECKLIST:                                                ║"
          echo "║  [✓] Secrets validados                                     ║"
          echo "║  [✓] Código validado                                       ║"
          echo "║  [✓] Banco restaurado                                      ║"
          echo "║  [✓] Deploy FTP concluído                                  ║"
          echo "║  [✓] Cache limpo                                           ║"
          echo "║  [✓] Pós-deploy validado                                   ║"
          echo "╚════════════════════════════════════════════════════════════╝"
